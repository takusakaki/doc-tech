#+TITLE:     Lerning Perl
#+LANGUAGE:  jp
#+TEXT

* 3. リストと配列

** 3.2
$#name  配列の最後のインデックス
⇒負のインデックスは末尾から数える
　$#name は $name[-1] と等しい

** 3.5
配列をダブルクォートの中に記述すると、スペース区切りで展開される

@rocks = qw{ flintstone slate rubble };
print "Three rocks are: @rocks.\n";
print "There's nothing in the parens (@empty) hear.\n";


*** 3.7.1
reverse演算子はリストを逆順に並べて返す

@rrr = reverse 1..10;
print "@rrr\n";
 10 9 8 7 6 5 4 3 2 1


** 3.8
配列の名前はスカラーコンテキストでは要素の個数を返す

@people = qw( fred barney betty );
print @people . "\n";
 3

*** 3.8.3
擬似関数 scalarで強制的にスカラーコンテキストを適用

@people = qw( fred barney betty );
print "num:", @people, "\n";   #  (NG) num:fredbarneybetty
print "num:", scalar @people, "\n";   #  (OK) num:3

** 3.9
<STDIN>
 スカラーコンテキストでは次の一行を読み込んで返す
 リストコンテキストではファイルの終りまで全てをリストで返す

* 4. サブルーチン

** 4.4
サブルーチンの中で最後に行われた計算の結果が戻り値となる

sub sum_two_nums {
  $a + $b;
}
$a=3;
$b=4;
print &sum_two_nums;
 ---
7


sub which_larger {
    if($a > $b) {
        $a;
    } else {
'         $b;
    }
}
$a=3;
$b=4;
print &which_larger;
 ---
4


** 4.5
パラメータ個数に過不足があってもエラーにはならない


[?] @_がグローバルな値をもっていればサブルーチンから
　　戻ってきた時点でもとに戻される
   ただし、サブルーチンを起動する際に、名前の前に&があり
   カッコあるいは引数がない場合、配列@_は呼び出し元の
   コンテキストから引き継がれる

sub sub1 {
    ($a, $b) = @_;
     $a = 5;
     $b = 6;
    &sub2;
    print "sub1:". $a .",". $b ."\n";
}
sub sub2 {
    ($a, $b) = @_;
     $a = 7;
     $b = 8;
    print "sub1:". $a .",". $b ."\n";
}
$a=3;
$b=4;
&sub1($a, $b);
print "main:". $a .",". $b ."\n";
 ---
sub2:7,8
sub1:7,8   <<< 5,6では?
main:7,8   <<< 3,4では?



** 4.8

 4.5の疑問に思った箇所について
 サブルーチンのパラメータをlocalで受けとれば
 4.5で期待していたような動作となる
sub sub1 {
    local($a, $b) = @_;
     $a = 5;
     $b = 6;
    &sub2;
    print "sub1:". $a .",". $b ."\n";
}
sub sub2 {
    local($a, $b) = @_;
     $a = 7;
     $b = 8;
    print "sub1:". $a .",". $b ."\n";
}
$a=3;
$b=4;
&sub1($a, $b);
print "main:". $a .",". $b ."\n";
 ---
sub1:7,8
sub1:5,6
main:3,4


*** 4.11.1

構文からサブルーチンであると判断できる場合は & を省略可能
  aaa($b);  # パラメータリストをカッコで囲む

  sub ccc {
   ...
  }
  ccc $d;   # サブルーチンの定義を終えたあと


サブルーチンの呼び出し時の & を省略したとき、
該当するPerlの組み込み関数があれば実行される
組み込み関数がなければサブルーチンが実行される。

* 5. ハッシュ

*** 5.2.2
逆引き用のハッシュの作成
 %inverse_hash = reverse %any_hash;

  ** 元のハッシュの値が重複している場合は、どれか１つになってしまう

*** 5.2.3
 '=>'
 Perlの文法ではカンマ(,)の代わりに(=>)で置き換えることができる

*** 5.3.2
  while ( ($key, $value) = each %hash ) {
    ....
  }

 each で2要素のリストを返す。
 whileの条件式はブール値コンテキストであり、
 ブール値コンテキストはスカラーコンテキストの一種。
 リストはスカラーコンテキストにおいて要素数を返すので
 %hashから全て取り出したあとは0になり、whileを抜ける

*** 5.4.1
  if (exists $books{"dino"}) {....

*** 5.4.2
  delete $books{"dino"};

*** 5.4.3
  my %hash = (a=>1, b=>2);
  print "%hash";
 ---
 %hash  
 
 変数展開されず、文字通り %hashと表示される

* 6. 入出力の基本

** 6.1
 while (<STDIN>){...} は
 while (defined($_ = <STDIN>)){...} と同じ(省略形)


 while (<STDIN>){...} は1要素ずつ取り出すが
 行入力演算子をリストコンテキストで評価すると
 残りの行を全て読み込んでリストにして返す
 foreach(<STDIN>){...} とすると全ての要素を読み込んでから
 ループされる
 よって大きいファイルを読み込む場合はwhileのほうがよい
  
** 6.2 ダイヤモンド演算子
 起動引数が未指定の場合、標準入力を処理
 指定されている場合、
  それらのファイルを処理
  複数指定されている場合は順に処理
  存在しないファイルを指定した場合はエラー
  - が指定されている場合は標準入力を処理

** 6.3
 ダイヤモンド演算子は @ARGV を見ている

** 6.4
 printは リストを受け取り、リストの要素を１つ１つ
 標準出力に送る
 
  my @ary = (1, 2, 3, 4);
  print @ary;
  ---
  1234

  "@ary"とすると配列が変数展開され "1 2 3 4"になるので
  print "@ary";
  ---
  1 2 3 4

 ダイヤモンド演算子は行のリストを返すので
  print <>;        はcatコマンド
  print sort <>;   はsortコマンド のようになる


 print (2+3)*4;
 ---
 5
   20ではない
    printは出力が成功したかどうかを1か0で返す
    よって、printを行った後、その結果の1と4を
    欠けているが何もせず捨てられる
    ** warningとなる

*** 6.5.1
 printfの引数に配列を指定、また配列の数に応じて
 printfのフォーマット部を動的に作成
  ** x演算子で繰り返す, @itemsは要素数
  my @items = qw( wilma dino pebbles);
  my $format = "%10s\n" x @items;
  printf $format, @items;

  ** さらに短縮
  my @items = qw( wilma dino pebbles);
  printf "%10s\n" x @items, @items;

* 7. 正規表現の基本
* 8. 正規表現の詳細

*** 8.1.1 
 文字クラスのショートカット
 \d :[0-9]        数字
 \w :[A-Za-z0-9_] ワード文字
 \s :[\f\t\n\r ]  空白文字

*** 8.1.2
 否定
 \D, \W, \S

 [\d\D]  全ての文字にマッチ
  ** 改行も含め全ての文字
     . は改行はマッチしない

 [^\d\D]  まったくマッチしない

** 8.3
 ^, $ をアンカーと呼ぶ
 
 /^\s*$/  空行

*** 8.3.1
 \b ワード境界アンカー
  \w文字で構成されていなければならない

 \B 非ワード境界アンカー

*** 8.4.1
 後方参照 \1, \2, ...
  /(.)\1/   同じ文字が連続すればマッチ

* 9. 正規表現の利用法

** 9.1
/../ は m/../の省略形
省略しない場合は任意のデミリタを指定可能
　m{..}  m<..>  m!..! など

** 9.2
オプション演算子
 //i   大文字と小文字を区別しない
 //s   .を改行文字にもマッチさせる
 
** 9.3
 =~ 結合演算子

*** 9.5.2
マッチ変数
 $& マッチした部分
 $` マッチした部分より前
 $' マッチした部分より後

 マッチ変数をどこか一箇所でも使っていると
 正規表現の実行が少し遅くなる


*** 9.6.2 
置換演算子で別のデミリタを使う
 s#..#..#;
 s{..}{..};
 s<..>[..];

*** 9.6.5
 \U 後ろに続くものを大文字にする
  s/(fred|barney)/\U$1/gi;

 \L は小文字
 \U,\Lの後ろに\Eがあればそこまで
 \u,\lは次の1文字だけ
 \u\L 全てを小文字, 1文字目だけ大文字

* 10. さまざまな制御構造

** 10.2
 until () {...}  
  whileの条件を反転

** 10.3
 式修飾子

 if 修飾子
  xxxxxxxx if $n < 0

 その他の式修飾子
  xxxx unless &valid();
  xxxx until $i > $j;
  xxxx while $n < 10;
  xxxx foreach @nnn;

 修飾子の両側には複数の文を置くことはできない
　foreachの場合、制御変数は常に $_ になる

** 10.7
 for (init; test; increment) {
  ...
 }
 内部的に以下のwhileループと同じ
 init;
 while (test) {
  ...
  increment;
 }

*** 10.7.1
foreach は forと完全に等価

*** 10.8.3
redo 現在の繰り返しを再実行


*** 10.8.4
ラベル付きブロック
LINE: while(<>) {
      foreach (..) {
            last LINE;
      }
} 

* 11. ファイルハンドルとファイルテスト

** 11.3
open LOG, ">>logfile"
  or dir "Cannot create logfile: $!";

このorは || としてはいけない。
||は優先順位が高いので直前のファイル名の引数と結びついてしまう
||を付ける場合はカッコで囲む必要がある


*** 11.4.1
select AAAA;
print "aaaaaaaaaa";
デフォルトの出力ファイルハンドルを変更

$|=1とすると現在のファイルハンドルのバッファを
バッファリングしなくなる（即座にフラッシュ）
select AAAA;
$|=1;
select STDOUT;
print AAAA "aaaaaaaa:;

** 11.5
標準ファイルハンドルを再オープン
 open STDERR, ">>", "error.log";

*** 11.6.2
my($sec, $min, $hour, 
 $day, $mon, $year,    #mon 0-11
 $wday, $yday, $isdat) #wday 0-6
 = localtime $timestamp;

localtime(gmttime)はパラメータを省略するとtimeが返す値（現在時刻）を用いる

*** 11.6.4
~10 = 0xFFFFFFF5 (32ビットマシン)
    = 0xFFFFFFFFFFFFFFF5 (64ビットマシン)

*** 11.6.5
下線ファイルハンドル _
ファイルテスト, stat, lstatは呼び出す度にシステムコールが行われるが
_ を指定すると前回のstatバッファの値をそのまま使う

* 12. ディレクトリ操作

** 12.2
 @all_files = glob "*";
 @pm_files  = glob "*.pm";
 
 ** ドットファイルは除外される 
    パターンで明示すれば該当するようになる

 複数のパターンを指定するときはスペース区切り
 @pm_files  = glob "*.pm *.pl";

 ** 5.6以前のPerlでは globが cshを呼び出していた

** 12.4 ディレクトリハンドル

 opendir DH, "/etc";
 foreach $file (readdir DH) {
     print "$file\n";
 }
 closedir DH;

 ** ドットファイルも含まれる 
 ** glob ではパターンに指定したディレクトリ付きの値が返されるが
     ディレクトリハンドルではファイル名だけ返される


* 追記 (2014-7-27)

** 永続的なプライベート変数
state
2回目以降は無視される

** デフォルトの出力ファイルハンドルSTDOUTを変える
select

** 文字クラスのショートカット
\h   水平空白文字にマッチング。
  \h は水平空白と考えられる任意の文字にマッチングします。 これはスペースと タブ文字です。 
  \H は水平空白と考えられない文字にマッチングします。

\v   垂直空白文字にマッチング。
  \v は垂直空白と考えられる任意の文字にマッチングします。 これは復帰と 行送り(改行)文字です。
  \V は垂直空白と考えられない任意の文字にマッチングします。

\R
  \R は Unicode の規則で改行と考えられるものにマッチングします。 
  複数文字の並びにマッチングすることもあるので、これは 文字クラスではありません。 
  従って、大かっこ文字クラスの中では使えません。

** 正規表現オプション
/x 空白文字を追加 
  パターン内のスペースとタブは無視されるようになる
  コメントを混ぜることも可能になる

** 名前付きキャプチャ
(?<LABEL>PATTERN) 
  %+  というハッシュに記録される
  $+{<LABEL>}

** たくさんのファイルを更新する
$^I = ".bak"

** system 
複数の引数に分割するとシェルは起動されない
バッククォートの場合は使用できない

バッククォートで実行した結果が複数行の場合、リストコンテキストで受けとると自動的に行に分割される
(自前で改行で分割しなくてもよくなる) 
各行の末尾には改行がついている
また、例えばforeach()に渡せば各行が順に処理される
